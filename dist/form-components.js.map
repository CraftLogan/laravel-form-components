{"version":3,"file":"form-components.js","sources":["../resources/js/util/findLastIndex.js","../resources/js/util/inspect.js","../resources/js/util/regex.js","../resources/js/util/identity.js","../resources/js/util/get.js","../resources/js/util/options.js","../resources/js/components/index.js","../resources/js/components/custom-select.js"],"sourcesContent":["export default (array, predicate) => {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) {\n            return l;\n        }\n    }\n\n    return -1;\n};\n","export const isArray = val => Array.isArray(val);\n\nexport const isUndefined = val => val === undefined;\n\nexport const isNull = val => val === null;\n\nexport const isUndefinedOrNull = val => isUndefined(val) || isNull(val);\n\n// Quick object check.\n// This is primarily used to tell Objects from primitive values\n// when we know the value is a JSON-compliant type.\n// Note: object could be a complex type like array, Date, etc.\nexport const isObject = obj => obj !== null && typeof obj === 'object';\n\n// Strict object type check.\n// Only returns true for plain JavaScript objects.\nexport const isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]';\n","export const RX_ARRAY_NOTATION = /\\[(\\d+)]/g;","const identity = x => x;\n\nexport default identity;\n","import { isArray, isNull, isObject, isUndefinedOrNull } from './inspect';\nimport { RX_ARRAY_NOTATION } from './regex';\nimport identity from './identity';\n\n/**\n * Get property defined by dot/array notation in string, returns undefined if not found.\n *\n * @param {Object} obj\n * @param {String|Array} path\n * @param {*} defaultValue\n * @return {*}\n */\nexport const getRaw = (obj, path, defaultValue = undefined) => {\n    // Handle array of path values.\n    path = isArray(path) ? path.join('.') : path;\n    \n    // If no path or object passed.\n    if (! path || ! isObject(obj)) {\n        return defaultValue;\n    }\n    \n    // Handle edge case where user has dot(s) in top-level item field key.\n    // Using `in` operator vs `hasOwnProperty` to handle obj.prototype getters.\n    if (path in obj) {\n        return obj[path];\n    }\n    \n    // Handle string array notation (numeric indices only).\n    path = String(path).replace(RX_ARRAY_NOTATION, '.$1');\n    \n    const steps = path.split('.').filter(identity);\n    \n    // Handle case where someone passes a string of only dots\n    if (steps.length === 0) {\n        return defaultValue;\n    }\n    \n    // Traverse path in object to find result.\n    // Using `in` operator vs `hasOwnProperty` to handle obj.prototype getters.\n    return steps.every(step => isObject(obj) && step in obj && ! isUndefinedOrNull((obj = obj[step])))\n        ? obj\n        : isNull(obj)\n            ? null\n            : defaultValue;\n};\n\n/**\n * Get property by dot/array notation in string.\n * \n * @param {Object} obj\n * @param {String|Array} path\n * @param {*} defaultValue (optional)\n * @return {*}\n */\nexport const get = (obj, path, defaultValue = null) => {\n    const val = getRaw(obj, path);\n    \n    return isUndefinedOrNull(val) ? defaultValue : val;\n};\n\nexport default get;\n","import { isArray, isNull, isPlainObject, isUndefined } from './inspect';\nimport get from './get';\n\nexport const normalizeOption = (option, fields = {}, key = null) => {\n    // When the option is an object, normalize it.\n    if (isPlainObject(option)) {\n        const value = get(option, fields.valueField || 'value');\n        const text = get(option, fields.textField || 'text');\n        const options = get(option, fields.optionField || 'options');\n\n        // When it has options, create an `<optgroup>` object.\n        if (! isNull(options)) {\n            return {\n                label: String(get(option, fields.labelField || 'label') || text),\n                options: normalizeOptions(options),\n            };\n        }\n\n        // Otherwise create an `<option>` object.\n        return {\n            ...option,\n\n            value: isUndefined(value) ? key || text : value,\n            text: String(isUndefined(text) ? key : text),\n            disabled: Boolean(get(option, fields.disabledField || 'disabled')),\n        };\n    }\n\n    // Otherwise create an `<option>` object from the given value.\n    return {\n        value: key || option,\n        text: String(option),\n        disabled: false,\n    };\n};\n\nexport const normalizeOptions = (options, fields = {}) => {\n    // Normalize the given options array\n    if (isArray(options)) {\n        return flattenOptions(options.map(option => normalizeOption(option, fields)));\n    }\n\n    // If not an array or object, return an empty array.\n    return [];\n};\n\nconst flattenOptions = options => {\n    let mapped = [];\n\n    options.forEach(option => {\n        // If the option has a \"label\" property, it is an `<optgroup>`, and\n        // its options need to be pushed onto the base option array.\n        if (option.hasOwnProperty('label')) {\n            mapped.push({ label: option.label });\n            mapped = mapped.concat(option.options);\n        } else {\n            mapped.push(option);\n        }\n    });\n\n    return mapped;\n};\n","import customSelect from './custom-select';\n\nwindow.customSelect = customSelect;\n","/*\n * Custom Select Component Definition.\n *\n * Note: Not using polyfills for functions such as Array.from()\n * since I use Livewire, and Livewire already includes polyfills\n * for those functions. If you don't use Livewire, you should\n * make sure are pulling in those polyfills.\n */\n\nimport findLastIndex from '../util/findLastIndex';\nimport { normalizeOptions } from '../util/options';\nimport { isArray } from '../util/inspect';\n\nexport default function customSelect(config) {\n    return {\n        focusedOptionIndex: null,\n        filterable: false,\n        data: [],\n        disabled: false,\n        options: [],\n        open: false,\n        search: '',\n        wireFilter: false,\n        wireListeners: [],\n        value: '',\n        selectedOption: null, // for storing a selected option in case a \"wire:filter\" removes the option from the list...\n        max: false,\n        selectId: '',\n        valueField: 'value',\n        textField: 'text',\n        disabledField: 'disabled',\n        labelField: 'label', // used for an \"optgroup\"'s label\n        optionsField: 'options', // used when creating \"optgroups\"\n        fixedPosition: false,\n        positionOnTop: false,\n        ...config,\n\n        get buttonDisplay() {\n            if (this.multiple) {\n                let optionDisplay = this.optionDisplay(this.value[0]);\n\n                if (this.value.length > 1) {\n                    optionDisplay += ` <span class=\"custom-select__select-count\">+ ${this.value.length - 1}</span>`;\n                }\n\n                return optionDisplay;\n            }\n\n            return this.optionDisplay(this.value);\n        },\n\n        get fieldNames() {\n            return {\n                valueField: this.valueField,\n                textField: this.textField,\n                disabledField: this.disabledField,\n                labelField: this.labelField,\n                optionsField: this.optionsField,\n            };\n        },\n\n        close() {\n            this.open = false;\n            this.focusedOptionIndex = null;\n            this.search = '';\n        },\n\n        clear() {\n            this.value = this.multiple ? [] : null;\n\n            if (this.open) {\n                this.close();\n                this.focusButton();\n            }\n        },\n\n        focusButton() {\n            this.$nextTick(() => this.$refs.button.focus());\n        },\n\n        focusNextOption() {\n            if (this.focusedOptionIndex === null) {\n                this.focusedOptionIndex = -1;\n            }\n\n            let nextIndex = this.options.findIndex((o, index) => index > this.focusedOptionIndex && ! o.disabled && ! this.isOptgroup(o));\n            if (nextIndex === -1 || (nextIndex + 1) > this.options.length) {\n                nextIndex = this.options.findIndex(o => ! o.disabled && ! this.isOptgroup(o));\n            }\n\n            this.focusedOptionIndex = nextIndex;\n\n            this.scrollToOption(this.focusedOptionIndex);\n        },\n\n        focusPreviousOption() {\n            if (this.focusedOptionIndex === null) {\n                this.focusedOptionIndex = this.options.length - 1;\n            }\n\n            let previousIndex = findLastIndex(this.options, (o, index) => index < this.focusedOptionIndex && ! o.disabled && ! this.isOptgroup(o));\n            if (previousIndex < 0) {\n                previousIndex = findLastIndex(this.options, o => ! o.disabled && ! this.isOptgroup(o));\n            }\n\n            this.focusedOptionIndex = previousIndex;\n\n            this.scrollToOption(this.focusedOptionIndex);\n        },\n\n        onHome() {\n            if (! this.open) {\n                return;\n            }\n\n            const firstIndex = this.options.findIndex(o => ! o.disabled && ! this.isOptgroup(o));\n\n            if (firstIndex > -1) {\n                this.focusedOptionIndex = firstIndex;\n\n                this.scrollToOption(this.focusedOptionIndex);\n            }\n        },\n\n        onEnd() {\n            if (! this.open) {\n                return;\n            }\n\n            const lastIndex = findLastIndex(this.options, o => ! o.disabled && ! this.isOptgroup(o));\n\n            if (lastIndex > -1) {\n                this.focusedOptionIndex = lastIndex;\n\n                this.scrollToOption(this.focusedOptionIndex);\n            }\n        },\n\n        isOptgroup(option) {\n            return option.hasOwnProperty('label');\n        },\n\n        isSelected(value) {\n            if (this.multiple) {\n                return this.value.includes(value);\n            }\n\n            return this.value === value;\n        },\n\n        init($wire = null) {\n            this.data = [...normalizeOptions(this.data, this.fieldNames)];\n            this.options = this.data;\n\n            if (this.multiple) {\n                this.selectedOption = [];\n            }\n\n            if (this.multiple && ! isArray(this.value)) {\n                this.value = [];\n            }\n\n            if (this.multiple && this.value.length > 0) {\n                this.selectedOption = this.options.find(o => ! this.isOptgroup(o) && o.value === this.value[0]);\n            } else if (! this.multiple && this.value) {\n                this.selectedOption = this.options.find(o => ! this.isOptgroup(o) && o.value === this.value);\n            }\n\n            // Allow local filtering if user has not specified wire:filter on the custom select component.\n            this.$watch('search', value => {\n                if (! this.open) {\n                    return this.options = this.data;\n                }\n\n                // If the user specifies a \"wire:filter\" method, attempt to call that method,\n                // otherwise just perform local search.\n                if (this.wireFilter && $wire) {\n                    $wire[this.wireFilter](value)\n                        .then(data => {\n                            this.data = normalizeOptions(data, this.fieldNames);\n                            this.options = this.data;\n                        });\n\n                    return;\n                }\n\n                if (! value) {\n                    return this.options = this.data;\n                }\n\n                const lowerCasedSearch = value.toLowerCase();\n\n                this.options = this.data\n                    .filter(o => ! this.isOptgroup(o) && (String(o.value).toLowerCase().includes(lowerCasedSearch) || o.text.toLowerCase().includes(lowerCasedSearch)));\n            });\n\n            if ($wire) {\n                // Wire listeners are useful for selects whose options depend on other selects. On the livewire component,\n                // user can emit an event with the options that should be shown in the dependant select based on some\n                // criteria.\n                this.wireListeners.forEach(listener => {\n                    $wire.on(listener, data => {\n                        this.data = normalizeOptions(data, this.fieldNames);\n                        this.options = this.data;\n                    });\n                });\n            }\n        },\n\n        onMouseover(option, index) {\n            if (this.isOptgroup(option) || option.disabled) {\n                return;\n            }\n\n            this.focusedOptionIndex = index;\n        },\n\n        optionClasses(option, index) {\n            const classes = [];\n\n            if (this.isOptgroup(option)) {\n                classes.push('custom-select__opt-group');\n            } else if (index === this.focusedOptionIndex) {\n                classes.push('custom-select__option--hovered');\n            }\n\n            if (this.isSelected(option.value)) {\n                classes.push('custom-select__option--selected');\n            }\n\n            if (option.disabled) {\n                classes.push('custom-select__option--disabled');\n            }\n\n            return classes.join(' ');\n        },\n\n        openMenu() {\n            if (this.disabled) {\n                return;\n            }\n\n            const firstValue = this.multiple ? this.value[0] : this.value;\n            this.focusedOptionIndex = this.options.findIndex(o => o.value === firstValue && ! this.isOptgroup(o));\n            if (this.focusedOptionIndex < 0) {\n                this.focusedOptionIndex = this.options.findIndex(o => ! o.disabled && ! this.isOptgroup(o));\n            }\n\n            this.open = true;\n\n            this.$nextTick(() => {\n                if (this.filterable) {\n                    this.$refs.search.focus({\n                        preventScroll: true,\n                    });\n                }\n\n                this.positionMenu();\n\n                this.scrollToOption(this.focusedOptionIndex);\n            });\n        },\n\n        optionDisplay(value) {\n            if (! value) {\n                return null;\n            }\n\n            let option = this.options.find(o => o.value === value);\n\n            if (! option && this.multiple && this.selectedOption.length > 0) {\n                option = this.selectedOption[0];\n            } else if (! option && this.selectedOption && this.selectedOption.value === value) {\n                option = this.selectedOption;\n            }\n\n            return (option || { text: null }).text;\n        },\n\n        onEnter() {\n            if (! this.open) {\n                return this.openMenu();\n            }\n\n            const option = this.options[this.focusedOptionIndex];\n\n            if (option) {\n                this.selectOption(option);\n            }\n        },\n\n        selectOption(option) {\n            if (option.disabled) {\n                return;\n            }\n\n            if (this.multiple) {\n                return this.selectOptionForMultiple(option);\n            }\n\n            if (this.value === option.value && this.optional) {\n                this.value = null;\n                this.selectedOption = null;\n            } else {\n                this.value = option.value;\n                this.selectedOption = option;\n            }\n\n            this.close();\n            this.focusButton();\n        },\n\n        selectOptionForMultiple(option) {\n            if (this.value.includes(option.value)) {\n                if (this.optional || this.value.length > 1) {\n                    this.value.splice(this.value.indexOf(option.value), 1);\n                    this.selectedOption.splice(this.selectedOption.findIndex(o => o.value === option.value), 1);\n                }\n\n                if (this.value.length === 0) {\n                    this.selectedOption = [];\n                    this.close();\n                    this.focusButton();\n                }\n\n                return;\n            }\n\n            if (! this.max || Number(this.max) > this.value.length) {\n                this.value.push(option.value);\n                this.selectedOption.push(option);\n            }\n        },\n\n        hasSelection() {\n            if (this.multiple) {\n                return this.value.length > 0;\n            }\n\n            return Boolean(this.value);\n        },\n\n        scrollToOption(index) {\n            if (index === 0 && this.options.length > 1) {\n                index = 1;\n            }\n\n            try {\n                this.$refs.listbox.children[index].scrollIntoView({\n                    block: 'center',\n                });\n            } catch (e) {}\n        },\n\n        toggle() {\n            if (this.open) {\n                return this.close();\n            }\n\n            this.openMenu();\n        },\n\n        positionMenu() {\n            if (this.fixedPosition) {\n                return this.positionFixedMenu();\n            }\n\n            this.$refs.container.style.marginTop = null;\n            this.positionOnTop = false;\n\n            // give a little bit of breathing room at the bottom of the screen.\n            const tolerance = 10;\n            const menuHeight = this.$refs.listbox.offsetHeight;\n            const largestHeight = window.innerHeight - menuHeight - tolerance;\n\n            const { top } = this.$refs.listbox.getBoundingClientRect();\n\n            if (top > largestHeight) {\n                this.positionOnTop = true;\n                this.$refs.container.style.marginTop = `-${this.$refs.button.offsetHeight + menuHeight + 20}px`\n            }\n        },\n\n        positionFixedMenu() {\n            // So we can accurately determine where it should be placed...\n            this.$refs.container.style.position = 'absolute';\n            this.$refs.container.style.top = null;\n\n            const { width, left: buttonLeft, top: buttonTop } = this.$refs.button.getBoundingClientRect();\n\n            // give a little breathing room at the bottom of the screen.\n            const tolerance = 40;\n            const menuHeight = this.$refs.listbox.offsetHeight;\n            const largestHeight = window.innerHeight - menuHeight - tolerance;\n\n            const { top } = this.$refs.container.getBoundingClientRect();\n\n            if (top > largestHeight) {\n                const buttonHeight = this.$refs.button.offsetHeight;\n                const menuTop = buttonTop - menuHeight - 25 - buttonHeight;\n                this.$refs.container.style.top = `${menuTop}px`;\n            } else {\n                this.$refs.container.style.top = `${top}px`;\n            }\n\n            this.$refs.container.style.position = 'fixed';\n            this.$refs.container.style.width = `${width}px`;\n            this.$refs.container.style.left = `${buttonLeft}px`;\n        },\n    };\n};\n"],"names":["array","predicate","l","length","isArray","val","Array","isUndefined","undefined","isNull","isUndefinedOrNull","isObject","obj","_typeof","isPlainObject","Object","prototype","toString","call","RX_ARRAY_NOTATION","identity","x","getRaw","path","defaultValue","join","steps","String","replace","split","filter","every","step","get","normalizeOption","option","fields","key","value","valueField","text","textField","options","optionField","disabled","Boolean","disabledField","label","labelField","normalizeOptions","flattenOptions","map","mapped","forEach","hasOwnProperty","push","concat","window","customSelect","config","focusedOptionIndex","filterable","data","open","search","wireFilter","wireListeners","selectedOption","max","selectId","optionsField","fixedPosition","positionOnTop","this","multiple","optionDisplay","close","clear","focusButton","$nextTick","_this","$refs","button","focus","focusNextOption","nextIndex","findIndex","o","index","_this2","isOptgroup","scrollToOption","focusPreviousOption","previousIndex","findLastIndex","_this3","onHome","firstIndex","_this4","onEnd","lastIndex","_this5","isSelected","includes","init","$wire","fieldNames","find","_this6","$watch","then","lowerCasedSearch","toLowerCase","listener","on","onMouseover","optionClasses","classes","openMenu","firstValue","_this7","preventScroll","positionMenu","onEnter","selectOption","selectOptionForMultiple","optional","splice","indexOf","Number","hasSelection","listbox","children","scrollIntoView","block","e","toggle","positionFixedMenu","container","style","marginTop","menuHeight","offsetHeight","largestHeight","innerHeight","getBoundingClientRect","top","position","width","buttonLeft","left","buttonTop","menuTop"],"mappings":"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"}